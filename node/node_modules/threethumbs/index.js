var path = require('path'),
	easyimg = require('easyimage'),
    async = require('async'),
    fs = require('fs'),
    targetWidth =  getWidth(parseInt(process.argv[2])),
    activeItem, 
    that = this;
    
// Callback implementation for async.series
function onSeriesReady(callback) {

    // If activeItem isn't set or we've processed all the image sizes, pop the next 
    if(!activeItem || activeItem.length <= 1) {

        activeItem = that.queue.pop();

        }
    
    // The file var should be something like: [ 'path', size<int> [, size<int>] ]
    // As such, we pop each size value untill we're down to just the filename
    // (identified in the queue.pop test above) then move to the next item
    var file = activeItem[0]; 
    var width = activeItem.pop();

    var fullpath = path.resolve('../../generated' + path.sep + file + '.jpg');

    fs.exists(fullpath, function(exists) {
        if (exists) {

            resize(fullpath, file, width, callback);

        } else {

            callback(null, null);

        }

    });

}

// Valid width or default of 200
function getWidth(w) {
	return (w && w > 10) ? w : 200;
}

// Perform the actual resize operation by calling easyimg with the accumulated options
function resize(fullpath, name, width, done) {

    var started = process.hrtime();
    
	var ext = path.extname(fullpath);
	var options = {
		src: fullpath, 
		dst: rename(fullpath, '_' + width, ext),
		width: width
	};
    
    process.stdout.write(".");

	easyimg.resize(options, function (err, image) {

        if (err) {
            done(err, name);
            return;
        }
        
	    done(null, [name, width, elapsed(started), err]);

	});

}

function elapsed(started, note){

    var elapsed = process.hrtime(started)[1] / 1000000; // divide by a million to get nano to milli
    return elapsed.toFixed(1) + "ms";  // To 1 decimal place
    
}
    
// Append the file size to the given path
function rename(filePath, append, ext) {

	// Strip extension, append text, push extension and resolve
	return path.resolve(
		path.dirname(filePath),
		path.basename(filePath, ext) + append + ext)

}

// Exported functionality (.generate)
function resizeFiles(fileInfo, done) {

    // Callback array for async.series
    var methods = [];
    
    // Loop over each definiton and add a callback to onSeriesReady for each thumb size entry
    fileInfo.forEach(function(fi) {
    
        var sizes = fi.slice(1);
        
        for(var i = 0, length = sizes.length; i < length; i++) {
            methods.push(onSeriesReady);
        }
        
    });

    // File info list
    this.queue = fileInfo;
    
    console.log('\nResizing Files:');

    // Run resize for each file in a serial fashion ( to prevent overloading 
    // the filesystem with concurrent requests)
    async.series(methods, function(err, res) { 
    
        done(err, res);
        
    });

}

module.exports.generate = resizeFiles;
